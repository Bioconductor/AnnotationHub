<!--
% \VignetteIndexEntry{AnnotationHub: AnnotationHub HOW TO's}
% \VignetteDepends{AnnotationHub}
% \VignetteEngine{knitr::knitr}
-->

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# AnnotationHub HOW To's

**Package**: `r Biocpkg("AnnotationHub")`<br />
**Authors**: `r packageDescription("AnnotationHub")[["Author"]] `<br />
**Modified**: 20 May, 2015<br />
**Compiled**: `r date()`


# Acccessing Epigenome RoadMap Project Data from AnnotationHub


All Epigenome roadmap files are hosted [here](http://egg2.wustl.edu/roadmap/data/byFileType/)

If one had to download these files on their own, one would use something like
the following R code.

```{r, eval=FALSE}
url <- "http://egg2.wustl.edu/roadmap/data/byFileType/peaks/consolidated/broadPeak/E001-H3K4me1.broadPeak.gz"
filename = basename(url)
download.file(url, destfile=filename)
if(file.exists(filename)){
   data <- import(filename, format="bed")
}
```
This would have to be repeated for all the files and the onus would lie on the
user to make sure he populates a list of all possible files that he's 
interested in, download them and then read those files into R using the
appropriate functions.

`r Biocpkg("AnnotationHub")` reduces this task to just a few lines of Rcode 
```{r results='hide'}
library(AnnotationHub)
ah = AnnotationHub()
epiFiles <- query(ah, "EpigenomeRoadMap")
```
A closer look at the show method tells us that `r length(epiFiles)` are 
available to us via `r Biocpkg("AnnotationHub")`. And apart from the files we can get 
information about the files ie where the files came from (dataprovider),
genome, species, sourceurl, sourcetypes. 
```{r}
epiFiles
```

A good sanity check to ensure that we have files only from EpigenomeRoadMap
project, is to check that all the files in the returned smaller hub object, 
come from Homo sapiens and the same genome 
```{r}
unique(epiFiles$species)
unique(epiFiles$genome)
```
Broadly, one can get an idea of the different files from this project 
looking at the sourcetype
```{r}
table(epiFiles$sourcetype)
```

To get a more descriptive idea of these different files one can use:
```{r}
sort(table(epiFiles$description))
```

The metadata underlying these files is also available. Note that the show 
method is quite different for 1 file as compared to a group of files. 
```{r}
metadata.tab <- query(ah , c("EpigenomeRoadMap", "Metadata"))
metadata.tab
```

One can retrieve the whole file using the '[[' as indicated at
the end of the show method

```{r results='hide'}
metadata.tab <- ah[["AH41830"]]
```

The metadata.tab file is returned as a data.frame and the first 6 rows of the 
first 5 columns are shown here

```{r}
head(metadata.tab[,1:5])
```

One can keep constructing different queries using multiple arguments to 
trim down these `r length(epiFiles)` to get the files one wants. 
For example, to get the chipseq files for consolidated epigenomes, 
one could use
```{r}
bpChipEpi <- query(ah , c("EpigenomeRoadMap", "broadPeak", "chip", "consolidated"))
```

Or To get all the bigWig signal files, one can query the hub using 
```{r}
allBigWigFiles <- query(ah, c("EpigenomeRoadMap", "BigWig"))
```

Or to access the 15 state chromatin segmentations, one can use
```{r}
seg <- query(ah, c("EpigenomeRoadMap", "segmentations"))
```

Or one might be interested in getting all the files related to one sample
```{r}
E126 <- query(ah , c("EpigenomeRoadMap", "E126", "H3K4ME2"))
E126
```

Where possible the files are parsed and returned as the appropriate object. 
For example, the peak files are returned as _GRanges_ objects.

```{r results='hide'}
gr19 <- E126[['AH29817']]
```
```{r}
gr19
seqinfo(gr19)
```
The bigWig files are returned as _BigWigFile_ objects which you can then read
in using rtracklayer::import()

Each record inside `r Biocpkg("AnnotationHub")` is associated with a unique 
identifier. Most _GRanges_ object contain a metadata slot which contains the unique 
AnnotationHub identifier. This can come handy when a user has been working with
the _GRanges_ object for a while, and wants to retrive the name of the file
or the sourceurl for the _GRanges_ object that he/she is working with.

```{r}
metadata(gr19)
ah[metadata(gr19)$AnnotationHubName]$sourceurl
```

##LiftOver Example

Let us assume we wanted to lift features from one genome build to the other.
We know that UCSC provides liftover tools for such tasks. 

In this example, we will take our broad Peak _GRanges_ from E126 which comes
from 'hg19' genome and liftover features to 'hg18'

```{r}
chainfiles <- query(ah , c("hg38", "hg19", "chainfile"))
chainfiles
```

We are interested in the one which lifts over features from hg19 to hg 18
so lets download that using 

```{r results='hide'}
chain <- chainfiles[['AH14150']]
```
```{r}
chain
```
Lets perform the liftOver operation using `r Biocpkg("rtracklayer")` 

```{r}
library(rtracklayer)
gr18 <- liftOver(gr19, chain)
```
This returns a _GRangeslist_ -One can specify the genome to get the final result 

```{r}
genome(gr18) <- "hg18"
gr18
``` 

## Get Variants from dbSNP 

One may also be interested in finding out "common" germline variations with 
evidence of medical interest. This information is available at NCBI 
[here](http://www.ncbi.nlm.nih.gov/variation/docs/human_variation_vcf/)

We need to get the "common_and_clinical.vcf.gz" from GRCh38. NCBI has 2 builds
- b141 and b14, for GRCh38 - we will query for files from b142

```{r}
vcf_file <- query(ah, c("grch38", "b142", "vcffile", "common_and_clinical"))
vcf_file
```
```{r results='hide', message=FALSE}
vcf <- ah[['AH47032']]
```
This returns a _VcfFile_ which can be read in using `r Biocpkg("VariantAnnotation")`

```{r message=FALSE}
library(VariantAnnotation)
vcf
vcfdata <- readVcf(vcf, genome="hg19")
```

_rowRanges_ contains information from the CHROM, POS and ID fields of the VCF 
file, represented as a _GRanges_

```{r}
vcf_rng <- rowRanges(vcfdata)
vcf_rng
```

Note that the broadPeaks follow the UCSC style of chromosome naming convention,
and the vcf data follows the NCBI style of chromosome naming convention. 
To bring both the broadPeaks from E126 and these ranges in the same chromosome
naming convention (ie UCSC), we would use

```{r}
seqlevelsStyle(vcf_rng) <-"UCSC"
```

And then finally to find which Variants overlap these broadPeaks we would use:

```{r}
overlap <- findOverlaps(vcf_rng, gr19)
overlap
```

One can then interpret the results in the following manner- In these broadPeaks

```{r}
gr19[head(subjectHits(overlap)),]
```
the following common variants were found 
```{r}
vcf_rng[head(queryHits(overlap)),]
```



# SessionInfo

```{r}
sessionInfo()
```

